# LEVEL 5

Same idea as before, I first tried encrypting 00. The encrypted result was a 10-byte long hex string, like so: 19b8803e8b19b5d39995. Additionally, encrypting 00 a second time gave a different result, meaning the scheme was non-deterministic. Encrypting 0000 also gave a 10-byte hex string, which led me to think that there is some padding going on, since the encrypted flag was long(meaning it wasn't going to be that all encryptions result in a 10-byte long string). Encrypting a longer string of 00s seemed to confirm this idea. It also led to another discovery; when encryting with a lot of 00s, there seemed to be repetition in the encrypted result, like so: e92583e282e92583e2abe92583e282.

With this in mind, I then needed to figure out what the blocksize was. We can do this by just sending messages with an extra 00 at a time and checking for when the encryption result's length increases, and doing this, I found that the blocksize seemed to be 5 bytes. Additionally, the encryption result increased in increments of 5 bytes rather than 10, which was the initial size, meaning it was likely there was some sort of IV block of length 5 bytes. Based on this and the previous discovery of the patterns showing up with encrypting long 00 strings, I figured the scheme went something like this: generate an IV block of 5 bytes at the front, and for all subsequent blocks, do a byte-wise addition of the message bytes in the block to the IV block.

After a while of more testing with other messages(sending messages like 0102030405, aaaaaaaaaaa, 1020304050, and other messages of varying lengths), I found two more things; 1) Not only was there addition, but there was also subtraction sometimes; and 2) the IV block seemed to be the very last block, rather than the first.(However, the encrypted blocks were in the same order as in the message.) There happens to be a operation commonly used in cryptography that does byte-wise addition and subtraction at times: XOR. So, my idea for the scheme at this point was: Generate and IV block, and for each 5-byte block in the message(after padding), XOR that block with the IV block, and add it to the result. After all blocks are cleared, the IV block is appended to the end. This idea would also support decryption working with non-determinism, as we can always decrypt as long as we know the IV block.

Note that my code does byte-wise XORs, which gives the same result as block-wise XORs(since everything is bitwise in the end). This was due to the fact that I was caught up with the addition and subtraction idea for a while... and once I realized it could be XOR, I just modified that single line.

The flag is ``Here we append the key with your shit, please dont tell anyone``
